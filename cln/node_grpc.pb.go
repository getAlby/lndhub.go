// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package cln

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
	Getinfo(ctx context.Context, in *GetinfoRequest, opts ...grpc.CallOption) (*GetinfoResponse, error)
	ListPeers(ctx context.Context, in *ListpeersRequest, opts ...grpc.CallOption) (*ListpeersResponse, error)
	ListFunds(ctx context.Context, in *ListfundsRequest, opts ...grpc.CallOption) (*ListfundsResponse, error)
	SendPay(ctx context.Context, in *SendpayRequest, opts ...grpc.CallOption) (*SendpayResponse, error)
	ListChannels(ctx context.Context, in *ListchannelsRequest, opts ...grpc.CallOption) (*ListchannelsResponse, error)
	AddGossip(ctx context.Context, in *AddgossipRequest, opts ...grpc.CallOption) (*AddgossipResponse, error)
	AutoCleanInvoice(ctx context.Context, in *AutocleaninvoiceRequest, opts ...grpc.CallOption) (*AutocleaninvoiceResponse, error)
	CheckMessage(ctx context.Context, in *CheckmessageRequest, opts ...grpc.CallOption) (*CheckmessageResponse, error)
	Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*CloseResponse, error)
	ConnectPeer(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	CreateInvoice(ctx context.Context, in *CreateinvoiceRequest, opts ...grpc.CallOption) (*CreateinvoiceResponse, error)
	Datastore(ctx context.Context, in *DatastoreRequest, opts ...grpc.CallOption) (*DatastoreResponse, error)
	CreateOnion(ctx context.Context, in *CreateonionRequest, opts ...grpc.CallOption) (*CreateonionResponse, error)
	DelDatastore(ctx context.Context, in *DeldatastoreRequest, opts ...grpc.CallOption) (*DeldatastoreResponse, error)
	DelExpiredInvoice(ctx context.Context, in *DelexpiredinvoiceRequest, opts ...grpc.CallOption) (*DelexpiredinvoiceResponse, error)
	DelInvoice(ctx context.Context, in *DelinvoiceRequest, opts ...grpc.CallOption) (*DelinvoiceResponse, error)
	Invoice(ctx context.Context, in *InvoiceRequest, opts ...grpc.CallOption) (*InvoiceResponse, error)
	ListDatastore(ctx context.Context, in *ListdatastoreRequest, opts ...grpc.CallOption) (*ListdatastoreResponse, error)
	ListInvoices(ctx context.Context, in *ListinvoicesRequest, opts ...grpc.CallOption) (*ListinvoicesResponse, error)
	SendOnion(ctx context.Context, in *SendonionRequest, opts ...grpc.CallOption) (*SendonionResponse, error)
	ListSendPays(ctx context.Context, in *ListsendpaysRequest, opts ...grpc.CallOption) (*ListsendpaysResponse, error)
	ListTransactions(ctx context.Context, in *ListtransactionsRequest, opts ...grpc.CallOption) (*ListtransactionsResponse, error)
	Pay(ctx context.Context, in *PayRequest, opts ...grpc.CallOption) (*PayResponse, error)
	ListNodes(ctx context.Context, in *ListnodesRequest, opts ...grpc.CallOption) (*ListnodesResponse, error)
	WaitAnyInvoice(ctx context.Context, in *WaitanyinvoiceRequest, opts ...grpc.CallOption) (*WaitanyinvoiceResponse, error)
	WaitInvoice(ctx context.Context, in *WaitinvoiceRequest, opts ...grpc.CallOption) (*WaitinvoiceResponse, error)
	WaitSendPay(ctx context.Context, in *WaitsendpayRequest, opts ...grpc.CallOption) (*WaitsendpayResponse, error)
	NewAddr(ctx context.Context, in *NewaddrRequest, opts ...grpc.CallOption) (*NewaddrResponse, error)
	Withdraw(ctx context.Context, in *WithdrawRequest, opts ...grpc.CallOption) (*WithdrawResponse, error)
	KeySend(ctx context.Context, in *KeysendRequest, opts ...grpc.CallOption) (*KeysendResponse, error)
	FundPsbt(ctx context.Context, in *FundpsbtRequest, opts ...grpc.CallOption) (*FundpsbtResponse, error)
	SendPsbt(ctx context.Context, in *SendpsbtRequest, opts ...grpc.CallOption) (*SendpsbtResponse, error)
	SignPsbt(ctx context.Context, in *SignpsbtRequest, opts ...grpc.CallOption) (*SignpsbtResponse, error)
	UtxoPsbt(ctx context.Context, in *UtxopsbtRequest, opts ...grpc.CallOption) (*UtxopsbtResponse, error)
	TxDiscard(ctx context.Context, in *TxdiscardRequest, opts ...grpc.CallOption) (*TxdiscardResponse, error)
	TxPrepare(ctx context.Context, in *TxprepareRequest, opts ...grpc.CallOption) (*TxprepareResponse, error)
	TxSend(ctx context.Context, in *TxsendRequest, opts ...grpc.CallOption) (*TxsendResponse, error)
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	Feerates(ctx context.Context, in *FeeratesRequest, opts ...grpc.CallOption) (*FeeratesResponse, error)
	GetRoute(ctx context.Context, in *GetrouteRequest, opts ...grpc.CallOption) (*GetrouteResponse, error)
	ListForwards(ctx context.Context, in *ListforwardsRequest, opts ...grpc.CallOption) (*ListforwardsResponse, error)
	ListPays(ctx context.Context, in *ListpaysRequest, opts ...grpc.CallOption) (*ListpaysResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	SignMessage(ctx context.Context, in *SignmessageRequest, opts ...grpc.CallOption) (*SignmessageResponse, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) Getinfo(ctx context.Context, in *GetinfoRequest, opts ...grpc.CallOption) (*GetinfoResponse, error) {
	out := new(GetinfoResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Getinfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListPeers(ctx context.Context, in *ListpeersRequest, opts ...grpc.CallOption) (*ListpeersResponse, error) {
	out := new(ListpeersResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListFunds(ctx context.Context, in *ListfundsRequest, opts ...grpc.CallOption) (*ListfundsResponse, error) {
	out := new(ListfundsResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SendPay(ctx context.Context, in *SendpayRequest, opts ...grpc.CallOption) (*SendpayResponse, error) {
	out := new(SendpayResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/SendPay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListChannels(ctx context.Context, in *ListchannelsRequest, opts ...grpc.CallOption) (*ListchannelsResponse, error) {
	out := new(ListchannelsResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) AddGossip(ctx context.Context, in *AddgossipRequest, opts ...grpc.CallOption) (*AddgossipResponse, error) {
	out := new(AddgossipResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/AddGossip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) AutoCleanInvoice(ctx context.Context, in *AutocleaninvoiceRequest, opts ...grpc.CallOption) (*AutocleaninvoiceResponse, error) {
	out := new(AutocleaninvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/AutoCleanInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CheckMessage(ctx context.Context, in *CheckmessageRequest, opts ...grpc.CallOption) (*CheckmessageResponse, error) {
	out := new(CheckmessageResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/CheckMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Close(ctx context.Context, in *CloseRequest, opts ...grpc.CallOption) (*CloseResponse, error) {
	out := new(CloseResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ConnectPeer(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ConnectPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CreateInvoice(ctx context.Context, in *CreateinvoiceRequest, opts ...grpc.CallOption) (*CreateinvoiceResponse, error) {
	out := new(CreateinvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/CreateInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Datastore(ctx context.Context, in *DatastoreRequest, opts ...grpc.CallOption) (*DatastoreResponse, error) {
	out := new(DatastoreResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Datastore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CreateOnion(ctx context.Context, in *CreateonionRequest, opts ...grpc.CallOption) (*CreateonionResponse, error) {
	out := new(CreateonionResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/CreateOnion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DelDatastore(ctx context.Context, in *DeldatastoreRequest, opts ...grpc.CallOption) (*DeldatastoreResponse, error) {
	out := new(DeldatastoreResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/DelDatastore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DelExpiredInvoice(ctx context.Context, in *DelexpiredinvoiceRequest, opts ...grpc.CallOption) (*DelexpiredinvoiceResponse, error) {
	out := new(DelexpiredinvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/DelExpiredInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DelInvoice(ctx context.Context, in *DelinvoiceRequest, opts ...grpc.CallOption) (*DelinvoiceResponse, error) {
	out := new(DelinvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/DelInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Invoice(ctx context.Context, in *InvoiceRequest, opts ...grpc.CallOption) (*InvoiceResponse, error) {
	out := new(InvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Invoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListDatastore(ctx context.Context, in *ListdatastoreRequest, opts ...grpc.CallOption) (*ListdatastoreResponse, error) {
	out := new(ListdatastoreResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListDatastore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListInvoices(ctx context.Context, in *ListinvoicesRequest, opts ...grpc.CallOption) (*ListinvoicesResponse, error) {
	out := new(ListinvoicesResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListInvoices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SendOnion(ctx context.Context, in *SendonionRequest, opts ...grpc.CallOption) (*SendonionResponse, error) {
	out := new(SendonionResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/SendOnion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListSendPays(ctx context.Context, in *ListsendpaysRequest, opts ...grpc.CallOption) (*ListsendpaysResponse, error) {
	out := new(ListsendpaysResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListSendPays", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListTransactions(ctx context.Context, in *ListtransactionsRequest, opts ...grpc.CallOption) (*ListtransactionsResponse, error) {
	out := new(ListtransactionsResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Pay(ctx context.Context, in *PayRequest, opts ...grpc.CallOption) (*PayResponse, error) {
	out := new(PayResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Pay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListNodes(ctx context.Context, in *ListnodesRequest, opts ...grpc.CallOption) (*ListnodesResponse, error) {
	out := new(ListnodesResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) WaitAnyInvoice(ctx context.Context, in *WaitanyinvoiceRequest, opts ...grpc.CallOption) (*WaitanyinvoiceResponse, error) {
	out := new(WaitanyinvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/WaitAnyInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) WaitInvoice(ctx context.Context, in *WaitinvoiceRequest, opts ...grpc.CallOption) (*WaitinvoiceResponse, error) {
	out := new(WaitinvoiceResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/WaitInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) WaitSendPay(ctx context.Context, in *WaitsendpayRequest, opts ...grpc.CallOption) (*WaitsendpayResponse, error) {
	out := new(WaitsendpayResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/WaitSendPay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) NewAddr(ctx context.Context, in *NewaddrRequest, opts ...grpc.CallOption) (*NewaddrResponse, error) {
	out := new(NewaddrResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/NewAddr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Withdraw(ctx context.Context, in *WithdrawRequest, opts ...grpc.CallOption) (*WithdrawResponse, error) {
	out := new(WithdrawResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Withdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) KeySend(ctx context.Context, in *KeysendRequest, opts ...grpc.CallOption) (*KeysendResponse, error) {
	out := new(KeysendResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/KeySend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) FundPsbt(ctx context.Context, in *FundpsbtRequest, opts ...grpc.CallOption) (*FundpsbtResponse, error) {
	out := new(FundpsbtResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/FundPsbt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SendPsbt(ctx context.Context, in *SendpsbtRequest, opts ...grpc.CallOption) (*SendpsbtResponse, error) {
	out := new(SendpsbtResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/SendPsbt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SignPsbt(ctx context.Context, in *SignpsbtRequest, opts ...grpc.CallOption) (*SignpsbtResponse, error) {
	out := new(SignpsbtResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/SignPsbt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) UtxoPsbt(ctx context.Context, in *UtxopsbtRequest, opts ...grpc.CallOption) (*UtxopsbtResponse, error) {
	out := new(UtxopsbtResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/UtxoPsbt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) TxDiscard(ctx context.Context, in *TxdiscardRequest, opts ...grpc.CallOption) (*TxdiscardResponse, error) {
	out := new(TxdiscardResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/TxDiscard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) TxPrepare(ctx context.Context, in *TxprepareRequest, opts ...grpc.CallOption) (*TxprepareResponse, error) {
	out := new(TxprepareResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/TxPrepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) TxSend(ctx context.Context, in *TxsendRequest, opts ...grpc.CallOption) (*TxsendResponse, error) {
	out := new(TxsendResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/TxSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	out := new(DisconnectResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Feerates(ctx context.Context, in *FeeratesRequest, opts ...grpc.CallOption) (*FeeratesResponse, error) {
	out := new(FeeratesResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Feerates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetRoute(ctx context.Context, in *GetrouteRequest, opts ...grpc.CallOption) (*GetrouteResponse, error) {
	out := new(GetrouteResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/GetRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListForwards(ctx context.Context, in *ListforwardsRequest, opts ...grpc.CallOption) (*ListforwardsResponse, error) {
	out := new(ListforwardsResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListForwards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ListPays(ctx context.Context, in *ListpaysRequest, opts ...grpc.CallOption) (*ListpaysResponse, error) {
	out := new(ListpaysResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/ListPays", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SignMessage(ctx context.Context, in *SignmessageRequest, opts ...grpc.CallOption) (*SignmessageResponse, error) {
	out := new(SignmessageResponse)
	err := c.cc.Invoke(ctx, "/cln.Node/SignMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility
type NodeServer interface {
	Getinfo(context.Context, *GetinfoRequest) (*GetinfoResponse, error)
	ListPeers(context.Context, *ListpeersRequest) (*ListpeersResponse, error)
	ListFunds(context.Context, *ListfundsRequest) (*ListfundsResponse, error)
	SendPay(context.Context, *SendpayRequest) (*SendpayResponse, error)
	ListChannels(context.Context, *ListchannelsRequest) (*ListchannelsResponse, error)
	AddGossip(context.Context, *AddgossipRequest) (*AddgossipResponse, error)
	AutoCleanInvoice(context.Context, *AutocleaninvoiceRequest) (*AutocleaninvoiceResponse, error)
	CheckMessage(context.Context, *CheckmessageRequest) (*CheckmessageResponse, error)
	Close(context.Context, *CloseRequest) (*CloseResponse, error)
	ConnectPeer(context.Context, *ConnectRequest) (*ConnectResponse, error)
	CreateInvoice(context.Context, *CreateinvoiceRequest) (*CreateinvoiceResponse, error)
	Datastore(context.Context, *DatastoreRequest) (*DatastoreResponse, error)
	CreateOnion(context.Context, *CreateonionRequest) (*CreateonionResponse, error)
	DelDatastore(context.Context, *DeldatastoreRequest) (*DeldatastoreResponse, error)
	DelExpiredInvoice(context.Context, *DelexpiredinvoiceRequest) (*DelexpiredinvoiceResponse, error)
	DelInvoice(context.Context, *DelinvoiceRequest) (*DelinvoiceResponse, error)
	Invoice(context.Context, *InvoiceRequest) (*InvoiceResponse, error)
	ListDatastore(context.Context, *ListdatastoreRequest) (*ListdatastoreResponse, error)
	ListInvoices(context.Context, *ListinvoicesRequest) (*ListinvoicesResponse, error)
	SendOnion(context.Context, *SendonionRequest) (*SendonionResponse, error)
	ListSendPays(context.Context, *ListsendpaysRequest) (*ListsendpaysResponse, error)
	ListTransactions(context.Context, *ListtransactionsRequest) (*ListtransactionsResponse, error)
	Pay(context.Context, *PayRequest) (*PayResponse, error)
	ListNodes(context.Context, *ListnodesRequest) (*ListnodesResponse, error)
	WaitAnyInvoice(context.Context, *WaitanyinvoiceRequest) (*WaitanyinvoiceResponse, error)
	WaitInvoice(context.Context, *WaitinvoiceRequest) (*WaitinvoiceResponse, error)
	WaitSendPay(context.Context, *WaitsendpayRequest) (*WaitsendpayResponse, error)
	NewAddr(context.Context, *NewaddrRequest) (*NewaddrResponse, error)
	Withdraw(context.Context, *WithdrawRequest) (*WithdrawResponse, error)
	KeySend(context.Context, *KeysendRequest) (*KeysendResponse, error)
	FundPsbt(context.Context, *FundpsbtRequest) (*FundpsbtResponse, error)
	SendPsbt(context.Context, *SendpsbtRequest) (*SendpsbtResponse, error)
	SignPsbt(context.Context, *SignpsbtRequest) (*SignpsbtResponse, error)
	UtxoPsbt(context.Context, *UtxopsbtRequest) (*UtxopsbtResponse, error)
	TxDiscard(context.Context, *TxdiscardRequest) (*TxdiscardResponse, error)
	TxPrepare(context.Context, *TxprepareRequest) (*TxprepareResponse, error)
	TxSend(context.Context, *TxsendRequest) (*TxsendResponse, error)
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	Feerates(context.Context, *FeeratesRequest) (*FeeratesResponse, error)
	GetRoute(context.Context, *GetrouteRequest) (*GetrouteResponse, error)
	ListForwards(context.Context, *ListforwardsRequest) (*ListforwardsResponse, error)
	ListPays(context.Context, *ListpaysRequest) (*ListpaysResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	SignMessage(context.Context, *SignmessageRequest) (*SignmessageResponse, error)
	mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (UnimplementedNodeServer) Getinfo(context.Context, *GetinfoRequest) (*GetinfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Getinfo not implemented")
}
func (UnimplementedNodeServer) ListPeers(context.Context, *ListpeersRequest) (*ListpeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPeers not implemented")
}
func (UnimplementedNodeServer) ListFunds(context.Context, *ListfundsRequest) (*ListfundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFunds not implemented")
}
func (UnimplementedNodeServer) SendPay(context.Context, *SendpayRequest) (*SendpayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPay not implemented")
}
func (UnimplementedNodeServer) ListChannels(context.Context, *ListchannelsRequest) (*ListchannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChannels not implemented")
}
func (UnimplementedNodeServer) AddGossip(context.Context, *AddgossipRequest) (*AddgossipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGossip not implemented")
}
func (UnimplementedNodeServer) AutoCleanInvoice(context.Context, *AutocleaninvoiceRequest) (*AutocleaninvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoCleanInvoice not implemented")
}
func (UnimplementedNodeServer) CheckMessage(context.Context, *CheckmessageRequest) (*CheckmessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckMessage not implemented")
}
func (UnimplementedNodeServer) Close(context.Context, *CloseRequest) (*CloseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedNodeServer) ConnectPeer(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectPeer not implemented")
}
func (UnimplementedNodeServer) CreateInvoice(context.Context, *CreateinvoiceRequest) (*CreateinvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInvoice not implemented")
}
func (UnimplementedNodeServer) Datastore(context.Context, *DatastoreRequest) (*DatastoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Datastore not implemented")
}
func (UnimplementedNodeServer) CreateOnion(context.Context, *CreateonionRequest) (*CreateonionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOnion not implemented")
}
func (UnimplementedNodeServer) DelDatastore(context.Context, *DeldatastoreRequest) (*DeldatastoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelDatastore not implemented")
}
func (UnimplementedNodeServer) DelExpiredInvoice(context.Context, *DelexpiredinvoiceRequest) (*DelexpiredinvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelExpiredInvoice not implemented")
}
func (UnimplementedNodeServer) DelInvoice(context.Context, *DelinvoiceRequest) (*DelinvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelInvoice not implemented")
}
func (UnimplementedNodeServer) Invoice(context.Context, *InvoiceRequest) (*InvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Invoice not implemented")
}
func (UnimplementedNodeServer) ListDatastore(context.Context, *ListdatastoreRequest) (*ListdatastoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDatastore not implemented")
}
func (UnimplementedNodeServer) ListInvoices(context.Context, *ListinvoicesRequest) (*ListinvoicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInvoices not implemented")
}
func (UnimplementedNodeServer) SendOnion(context.Context, *SendonionRequest) (*SendonionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendOnion not implemented")
}
func (UnimplementedNodeServer) ListSendPays(context.Context, *ListsendpaysRequest) (*ListsendpaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSendPays not implemented")
}
func (UnimplementedNodeServer) ListTransactions(context.Context, *ListtransactionsRequest) (*ListtransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTransactions not implemented")
}
func (UnimplementedNodeServer) Pay(context.Context, *PayRequest) (*PayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pay not implemented")
}
func (UnimplementedNodeServer) ListNodes(context.Context, *ListnodesRequest) (*ListnodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeServer) WaitAnyInvoice(context.Context, *WaitanyinvoiceRequest) (*WaitanyinvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitAnyInvoice not implemented")
}
func (UnimplementedNodeServer) WaitInvoice(context.Context, *WaitinvoiceRequest) (*WaitinvoiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitInvoice not implemented")
}
func (UnimplementedNodeServer) WaitSendPay(context.Context, *WaitsendpayRequest) (*WaitsendpayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitSendPay not implemented")
}
func (UnimplementedNodeServer) NewAddr(context.Context, *NewaddrRequest) (*NewaddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewAddr not implemented")
}
func (UnimplementedNodeServer) Withdraw(context.Context, *WithdrawRequest) (*WithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (UnimplementedNodeServer) KeySend(context.Context, *KeysendRequest) (*KeysendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeySend not implemented")
}
func (UnimplementedNodeServer) FundPsbt(context.Context, *FundpsbtRequest) (*FundpsbtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundPsbt not implemented")
}
func (UnimplementedNodeServer) SendPsbt(context.Context, *SendpsbtRequest) (*SendpsbtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPsbt not implemented")
}
func (UnimplementedNodeServer) SignPsbt(context.Context, *SignpsbtRequest) (*SignpsbtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignPsbt not implemented")
}
func (UnimplementedNodeServer) UtxoPsbt(context.Context, *UtxopsbtRequest) (*UtxopsbtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UtxoPsbt not implemented")
}
func (UnimplementedNodeServer) TxDiscard(context.Context, *TxdiscardRequest) (*TxdiscardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxDiscard not implemented")
}
func (UnimplementedNodeServer) TxPrepare(context.Context, *TxprepareRequest) (*TxprepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxPrepare not implemented")
}
func (UnimplementedNodeServer) TxSend(context.Context, *TxsendRequest) (*TxsendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxSend not implemented")
}
func (UnimplementedNodeServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedNodeServer) Feerates(context.Context, *FeeratesRequest) (*FeeratesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Feerates not implemented")
}
func (UnimplementedNodeServer) GetRoute(context.Context, *GetrouteRequest) (*GetrouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoute not implemented")
}
func (UnimplementedNodeServer) ListForwards(context.Context, *ListforwardsRequest) (*ListforwardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListForwards not implemented")
}
func (UnimplementedNodeServer) ListPays(context.Context, *ListpaysRequest) (*ListpaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPays not implemented")
}
func (UnimplementedNodeServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedNodeServer) SignMessage(context.Context, *SignmessageRequest) (*SignmessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessage not implemented")
}
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {}

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
	mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) {
	s.RegisterService(&Node_ServiceDesc, srv)
}

func _Node_Getinfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetinfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Getinfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Getinfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Getinfo(ctx, req.(*GetinfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListpeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListPeers(ctx, req.(*ListpeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListfundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListFunds(ctx, req.(*ListfundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SendPay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendpayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendPay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/SendPay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendPay(ctx, req.(*SendpayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListchannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListChannels(ctx, req.(*ListchannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_AddGossip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddgossipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AddGossip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/AddGossip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AddGossip(ctx, req.(*AddgossipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_AutoCleanInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutocleaninvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AutoCleanInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/AutoCleanInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AutoCleanInvoice(ctx, req.(*AutocleaninvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CheckMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckmessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CheckMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/CheckMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CheckMessage(ctx, req.(*CheckmessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Close(ctx, req.(*CloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ConnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ConnectPeer(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateinvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/CreateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CreateInvoice(ctx, req.(*CreateinvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Datastore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatastoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Datastore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Datastore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Datastore(ctx, req.(*DatastoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CreateOnion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateonionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CreateOnion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/CreateOnion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CreateOnion(ctx, req.(*CreateonionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DelDatastore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeldatastoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DelDatastore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/DelDatastore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DelDatastore(ctx, req.(*DeldatastoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DelExpiredInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelexpiredinvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DelExpiredInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/DelExpiredInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DelExpiredInvoice(ctx, req.(*DelexpiredinvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DelInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelinvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DelInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/DelInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DelInvoice(ctx, req.(*DelinvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Invoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Invoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Invoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Invoice(ctx, req.(*InvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListDatastore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListdatastoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListDatastore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListDatastore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListDatastore(ctx, req.(*ListdatastoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListinvoicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListInvoices(ctx, req.(*ListinvoicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SendOnion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendonionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendOnion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/SendOnion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendOnion(ctx, req.(*SendonionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListSendPays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListsendpaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListSendPays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListSendPays",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListSendPays(ctx, req.(*ListsendpaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListtransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListTransactions(ctx, req.(*ListtransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Pay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Pay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Pay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Pay(ctx, req.(*PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListnodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListNodes(ctx, req.(*ListnodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_WaitAnyInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitanyinvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).WaitAnyInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/WaitAnyInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).WaitAnyInvoice(ctx, req.(*WaitanyinvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_WaitInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitinvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).WaitInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/WaitInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).WaitInvoice(ctx, req.(*WaitinvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_WaitSendPay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitsendpayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).WaitSendPay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/WaitSendPay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).WaitSendPay(ctx, req.(*WaitsendpayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_NewAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewaddrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).NewAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/NewAddr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).NewAddr(ctx, req.(*NewaddrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Withdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Withdraw(ctx, req.(*WithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_KeySend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).KeySend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/KeySend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).KeySend(ctx, req.(*KeysendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_FundPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FundpsbtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).FundPsbt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/FundPsbt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).FundPsbt(ctx, req.(*FundpsbtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SendPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendpsbtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendPsbt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/SendPsbt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendPsbt(ctx, req.(*SendpsbtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SignPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignpsbtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SignPsbt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/SignPsbt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SignPsbt(ctx, req.(*SignpsbtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_UtxoPsbt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UtxopsbtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).UtxoPsbt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/UtxoPsbt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).UtxoPsbt(ctx, req.(*UtxopsbtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_TxDiscard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxdiscardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).TxDiscard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/TxDiscard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).TxDiscard(ctx, req.(*TxdiscardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_TxPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxprepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).TxPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/TxPrepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).TxPrepare(ctx, req.(*TxprepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_TxSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxsendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).TxSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/TxSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).TxSend(ctx, req.(*TxsendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Feerates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeratesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Feerates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Feerates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Feerates(ctx, req.(*FeeratesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetrouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/GetRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRoute(ctx, req.(*GetrouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListForwards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListforwardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListForwards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListForwards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListForwards(ctx, req.(*ListforwardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ListPays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListpaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ListPays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/ListPays",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ListPays(ctx, req.(*ListpaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignmessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cln.Node/SignMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SignMessage(ctx, req.(*SignmessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cln.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Getinfo",
			Handler:    _Node_Getinfo_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Node_ListPeers_Handler,
		},
		{
			MethodName: "ListFunds",
			Handler:    _Node_ListFunds_Handler,
		},
		{
			MethodName: "SendPay",
			Handler:    _Node_SendPay_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _Node_ListChannels_Handler,
		},
		{
			MethodName: "AddGossip",
			Handler:    _Node_AddGossip_Handler,
		},
		{
			MethodName: "AutoCleanInvoice",
			Handler:    _Node_AutoCleanInvoice_Handler,
		},
		{
			MethodName: "CheckMessage",
			Handler:    _Node_CheckMessage_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Node_Close_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _Node_ConnectPeer_Handler,
		},
		{
			MethodName: "CreateInvoice",
			Handler:    _Node_CreateInvoice_Handler,
		},
		{
			MethodName: "Datastore",
			Handler:    _Node_Datastore_Handler,
		},
		{
			MethodName: "CreateOnion",
			Handler:    _Node_CreateOnion_Handler,
		},
		{
			MethodName: "DelDatastore",
			Handler:    _Node_DelDatastore_Handler,
		},
		{
			MethodName: "DelExpiredInvoice",
			Handler:    _Node_DelExpiredInvoice_Handler,
		},
		{
			MethodName: "DelInvoice",
			Handler:    _Node_DelInvoice_Handler,
		},
		{
			MethodName: "Invoice",
			Handler:    _Node_Invoice_Handler,
		},
		{
			MethodName: "ListDatastore",
			Handler:    _Node_ListDatastore_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _Node_ListInvoices_Handler,
		},
		{
			MethodName: "SendOnion",
			Handler:    _Node_SendOnion_Handler,
		},
		{
			MethodName: "ListSendPays",
			Handler:    _Node_ListSendPays_Handler,
		},
		{
			MethodName: "ListTransactions",
			Handler:    _Node_ListTransactions_Handler,
		},
		{
			MethodName: "Pay",
			Handler:    _Node_Pay_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _Node_ListNodes_Handler,
		},
		{
			MethodName: "WaitAnyInvoice",
			Handler:    _Node_WaitAnyInvoice_Handler,
		},
		{
			MethodName: "WaitInvoice",
			Handler:    _Node_WaitInvoice_Handler,
		},
		{
			MethodName: "WaitSendPay",
			Handler:    _Node_WaitSendPay_Handler,
		},
		{
			MethodName: "NewAddr",
			Handler:    _Node_NewAddr_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Node_Withdraw_Handler,
		},
		{
			MethodName: "KeySend",
			Handler:    _Node_KeySend_Handler,
		},
		{
			MethodName: "FundPsbt",
			Handler:    _Node_FundPsbt_Handler,
		},
		{
			MethodName: "SendPsbt",
			Handler:    _Node_SendPsbt_Handler,
		},
		{
			MethodName: "SignPsbt",
			Handler:    _Node_SignPsbt_Handler,
		},
		{
			MethodName: "UtxoPsbt",
			Handler:    _Node_UtxoPsbt_Handler,
		},
		{
			MethodName: "TxDiscard",
			Handler:    _Node_TxDiscard_Handler,
		},
		{
			MethodName: "TxPrepare",
			Handler:    _Node_TxPrepare_Handler,
		},
		{
			MethodName: "TxSend",
			Handler:    _Node_TxSend_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Node_Disconnect_Handler,
		},
		{
			MethodName: "Feerates",
			Handler:    _Node_Feerates_Handler,
		},
		{
			MethodName: "GetRoute",
			Handler:    _Node_GetRoute_Handler,
		},
		{
			MethodName: "ListForwards",
			Handler:    _Node_ListForwards_Handler,
		},
		{
			MethodName: "ListPays",
			Handler:    _Node_ListPays_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Node_Ping_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _Node_SignMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "node.proto",
}
